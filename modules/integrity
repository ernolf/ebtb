__bashlib__
__path_and_modulename__
__version_and_datestring__
#
__copyright__
#
__license__
#

${INTEGRITY_BASHLIB:-_} && return
INTEGRITY_BASHLIB=:

# TODO 0 -->
. <(lrequire binaries)
. <(lrequire basics)
. <(lrequire awksed)
. <(lrequire line)
. <(lrequire sudo)
. <(lrequire vdir)
# TODO <-- 0
. <(lrequire gpg)
. <(lrequire cleanup)
. <(lrequire ebtb)

: ${D[ulb]:=/usr/local/bin}
: ${D[vts]:=${D[vt]}/scripts}

convene(){
    local script link
    ${C[ms]} ${D[vts]}
    # return if ${D[vts]} already is equal to the cannonical dir of runing script or if one of the commands is not yet in X array:
    [[ ${D[vts]} == $MD || -z ${X[cmp]} || -z ${X[ln]} ]] && return 0
    # copy from old to new path, remove old path and replace it with a symlink pointing to new path:
    ${X[cp]} --preserve=all "$MP" "${D[vts]}/${M[n]}" &&
        ${X[cmp]} -s "$MP" "${D[vts]}/${M[n]}" &&
        ${X[rm]} -f -- "$MP" &&
        mh "$(funcname_and_lineno) moved $MP to ${D[vts]}/${M[n]}"
    [[ ${M[b]} != ${M[n]} ]] &&
        ${X[ln]} -sfT "${D[vts]}/${M[n]}" "$MP" &&
        mh "$(funcname_and_lineno) created symlink: $MP -> ${D[vts]}/${M[n]}"
    for script in "${D[vts]}"/*; do
        [[ -x "$script" && -f "$script" ]] || continue
        link="${D[ulb]}/$(${X[basename]} "$script")"
        if [[ ! -L "$link" || "$(${X[realpath]} "$link")" != "$script" ]]; then
            ${X[ln]} -sfT "$script" "$link"
            mh "$(funcname_and_lineno) created symlink: $link -> $script"
        fi
    done
    if [ "$(${X[realpath]} "$MP")" = "${D[vts]}/${M[n]}" ]; then
        return 0
    else
        something_went_wrong "simlink creation with “${X[ln]} -sfT ${D[vts]}/${M[n]} $MP” failed"
#        mh "$(funcname_and_lineno) simlink creation failed"
        return 1
    fi
}

integrity_check(){
    local key mail aut vdir ddir shash ehash
    local -i r
    local -A bool tf
    bool[signed]=: tf[i]="$(tf shm)" tf[v]="$(tf shm)" r=1
    key="$(${X[sed]} -n 's/^# OpenPGP_Key\s*\(.*\)$/\1/p' "$MP")"
    mail="$(${X[sed]} -n 's/^# Email\s*\(.*\)$/\1/p' "$MP")"
    aut="$(${X[sed]} -n 's/^# Copyright.*\[\(.*\)\]/\\[\1\\]/p' "$MP")"
    su_root "to run the integrity check" integrity_check
    delp2ei '^-----BEGIN PGP SIGNATURE-----$' "$MP" "${tf[i]}"
    if [ -n "$vdirname" ]; then
        vdir=$(eval echo \$$vdirname) ddir=$(eval echo \$dflt_$vdirname)
        [ "$vdir" != "$ddir" ] && setvdir v d "${tf[i]}"
    fi
    shash="$(${X[sha256sum]} "${tf[i]}" | ${X[gawk]} '{print $1}')"
    ehash="$(${X[tail]} -n1 "$MP" | ${X[gawk]} '{print $NF}')"
    line '=' P 5/a
    if ! [[ $ehash =~ ^[a-fA-F0-9]{64}$ ]]; then
        mh "$(funcname_and_lineno) no sha256sum hash!"
        bool[signed]=_
        o5; R; echo "- No sha256sum hash, looks like script has not been signed!"
        line '-' P 5/a
    elif [ "$shash" != "$ehash" ]; then
        mh "$(funcname_and_lineno) wrong sha256sum hash!"
        o5; R; echo "- Wrong hash, looks like script has been tampered with!"
        line '-' P 5/a
    fi
    ${X[gpg]} --list-keys | ${X[grep]} -qs "$key" || q2 ${X[gpg]} --keyserver hkps://keyserver.ubuntu.com:443 --recv-keys "$key"
    ${X[gpg]} --list-keys | ${X[grep]} -qs "$key" || q2 ${X[gpg]} --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys "$key"
    ${X[gpg]} --list-keys | ${X[grep]} -qs "$key" || q2 gpg_assemble_key_ import ernolf_pubkey
    ${X[gpg]} --list-keys | ${X[grep]} -qs "$key" || {
        mh "$(funcname_and_lineno) import of public key failed"
        o5; R; echo "- import of public key failed."
        qpf; ask "Continue at own risk without check?" "$NO" && {
            ${X[sed]} -i 's/^v=false$/v=true/' "$MP" # this step must be done before convene, to not write back over the created symlink
            convene
            ebtb_is_installed janitor || { ebtb_install_script janitor && o5; Y; echo "The 'janitor' script provides system information. Simply run 'janitor'"; }
            cleanup_dangling_links ${D[ulb]}
            ${X[sleep]} .1
            line '=' P 5/a
            cleanup "${tf[i]}" "${tf[v]}"
            return 0
        }
    }
    ${X[gpg]} --verify "$MP" "${tf[i]}" > "${tf[v]}" 2>&1
    r=$?
    ${X[grep]} "$key" "${tf[v]}"
    ${X[grep]} "$aut (codesigning) <${mail//<at>/@}>" "${tf[v]}"
    line '-' P 5/a
    if (( r )); then
        o5; R; echo -n "- Integrity check of ${M[n]} $(blinkR)failed$(R). "
        if ${bool[signed]}; then
            mh "$(funcname_and_lineno) failed! modified"
            echo "The script may have been modified or tampered with!"
        else
            mh "$(funcname_and_lineno) failed! not signed"
            echo "This script does not appear to be signed!"
        fi
        line '-' P 5/a
        o5; B; echo "You should try this:"
        o5; GRAY; echo "sudo wget -O $MP $my_url"
        if ${bool[signed]}; then
            o5; B; echo ".. to fix this."; N
        else
            o5; B; echo ".. to get a signed version of this script or disable the integrity check."; N
            qpf; ask "Do you want to disable the integrity check at own risk" "$NO" && {
                echo -e "v=true\nnohash" >> "$MP" # this step must be done before convene, to not write back over the created symlink
                convene
                ebtb_is_installed janitor || { ebtb_install_script janitor && o5; Y; echo "The 'janitor' script provides system information. Simply run 'janitor'"; }
                cleanup_dangling_links ${D[ulb]}
                ${X[sleep]} .1
                line '=' P 5/a
                cleanup "${tf[i]}" "${tf[v]}"
                return 0
            }
        fi
    else
        ${X[sed]} -i 's/^v=false$/v=true/' "$MP" # this step must be done before convene, to not write back over the created symlink
        convene
        ebtb_is_installed janitor || { ebtb_install_script janitor && o5; Y; echo "The 'janitor' script provides system information. Simply run 'janitor'"; }
        cleanup_dangling_links ${D[ulb]}
        mh "$(funcname_and_lineno) passed"
        ${X[sleep]} .1
        o5; lG; echo "Integrity check of ${M[n]} passed. The script is authentic."; N
    fi
    line '=' P 5/a
    cleanup "${tf[i]}" "${tf[v]}"
    return $r
}

run_integrity_check(){
    mh "$(funcname_and_lineno) checking integrity"
    if integrity_check; then
        f
        o5; G; echo "Integrity check of ${M[n]} passed. Please start script again"
        exit 0
    else
        exit1
    fi
}

if "${B[do_integrity_check]:-_}"; then
    run_integrity_check
fi

declare $(tnh1 2)
if ! "${v:-_}"; then
    mh "$(funcname_and_lineno) first run"
    f
    o5; B; echo "First run of ${M[n]}, checking integrity:"
    run_integrity_check
fi
