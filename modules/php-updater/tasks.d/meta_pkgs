__bashlib__
__path_and_modulename__
__version_and_datestring__
#
__copyright__
#
__license__
#

${TASKS_META_PKGS_BASHLIB:-false} && return
TASKS_META_PKGS_BASHLIB=:

remove_meta_packages(){
    spinner C " . searching misconfigurations: meta-packages ." &
    populate_meta_pkgs_array
    mapfile -t META_PKGS< <(comm -12 <(p_sort_trim ${META_PKGS[@]}) <(p_sort_trim ${PKGS_BY_DPKG[@]%%/*}))
    if (( ${#META_PKGS[@]} )); then
        if ((${#META_PKGS[@]}==1)); then
            plu='is:' be='is a' modstring="$(B)${META_PKGS[0]}$(N)"
        else
            plu='ese:s' be='are' modstring="$(listify B ${META_PKGS[@]})"
        fi
        question="Q:$(format_string "Do you want to remove the meta package${plu#*:} $modstring now" 3)"
        kill_spinner
        bundle echo "$(xpf;format_string "There $be unnecessary $(O)meta package${plu#*:}$(N) ($modstring) installed on this machine." 3;N)"
        echo "$(ipf;Y;format_string "Meta packages do not contain actual software; they only depend on other packages to be installed. Essentially, they are package bundles that include multiple packages and SAPIs, many of which may not align with your specific use case. Removing a meta package does NOT remove the individual packages it installed. This script does not require these meta packages, as it manages package selection much more precisely without the \"scattershot\" approach. Consider to remove th${plu%:*} package${plu#*:} before updating. The removal makes your system more resilient against unintended changes made without your decision." 3;N)"
        echo " -$(format_string "This script can remove th${plu%:*} package${plu#*:} in a safe way." 3)"
        if ask "$question" "$YES"; then
            apt_remove --yes ${META_PKGS[@]}
            populate_pkgs_by_dpkg_array
            "$me${FLAG[forceflag]}" "json=$my_json" --list-installed-only
            anykey
            return 0
        else
            return 1
        fi
    else
        kill_spinner
        return 1
    fi
}
