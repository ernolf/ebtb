__shebang_bash__
__path_and_scriptname__
__version_and_datestring__
#
__copyright__
#
__license__
#

__whoami_whereami__
__scriptname__
__homedir__
__vdirname__ NC_DIR
modules=(fstring nc/nextcloud nc/occ)
__debug__
__when__
__tempdir__
__module_server__
__general__
__module_loader__
__module_integrity__
__nextcloud_updater__

contribute_(){
    . <(require contribute)
    contribute "https://help.nextcloud.com/t/script-nc-occ-interactive-occ-interface/195249"
}; donate_(){ contribute_;}
[[ "$@" =~ (donat|contrib) ]] && contribute_

# Directory containing the JSON output from 'occ list --format=json' and the favorites file
[[ -d ${D[occ]:=${D[vt]}/nc-occ-data} ]] || ${C[mw]} "${D[occ]}"
q0 ${X[chown]} -R "${NC[u]}":"${NC[g]}" "${D[occ]}"
declare -A NC_OCC_FAVORITES

# time in seconds during which the JSON object file is not updated
T[jttl]=300 # <- do not move this

# Bools to include all options and help option
B[include_all_options]=_
B[include_help]=_
B[help]=_

shopt -s extglob
for x in "$@"; do
    case "$x" in
   @(|-|--)php=*) if [[ " ${available_php_versions[*]} " =~ ${x#*=} ]]; then
                      php_version="${x#*=}" NC_OCC_BASHLIB=_
                      . <(lrequire nc/occ)
                  else
                      echo "$(Pbg) ERROR: php${x#*=} not found. $(N)"
                  fi                                   ;;
   @(|-|--)trace) B[trace]=:                           ;;
               *) args+=("$x")
    esac
done
set -- "${args[@]}"
shopt -u extglob

# Check for the arguments to include all options or just the help option
for x in "$@"; do
    case "$x" in
        -u|--update) T[jttl]=0                ;;
   -a|--all_options) B[include_all_options]=: ;;
        --show_help) B[include_help]=:        ;;
          -h|--help) B[help]=: T[jttl]=$(${X[grep]} -oP '^T\[jttl\]=\K\d+' $MP)
                     break
    esac
done

help_(){
    cat << HELP

    $(C)Simply run$(N)

        $(O)$ME$(N)

    $(G)to create your occ commands interactively.$(N)

    $(C)Possible options:$(N)

        $(O)-h $(GRAY)| $(O)--help$(N)
                $(o 17; GRAY; format_string "show this help message and exit" 17; N)
        $(O)-a $(GRAY)| $(O)--all_options$(N)
                $(o 17; GRAY; format_string "include the unimportant options $(W)help$(GRAY), $(W)quiet$(GRAY), $(W)verbose$(GRAY), $(W)version$(GRAY), $(W)ansi$(GRAY), $(W)no-ansi$(GRAY), $(W)no-interaction$(GRAY) and $(W)no-warnings" 17; N)
        $(O)-u $(GRAY)| $(O)--update$(N)
                $(o 17; GRAY; format_string "force an immediate update of the JSON object file" 17; N)
              $(Yi)Note: $(o 20; Y; format_string "The TTL of the JSON object file is $(C)${T[jttl]}$(Y) seconds. It contains the output of $(GRAY)\`$(C)occ list --format=json$(GRAY)\`$(Y), which in turn is used as the basis for the command-line structure of the occ commands created by this script." 20; N)
                    $(o 20; Y; format_string "If apps were installed, removed, or modified or the debug level in the config.php was changed within this time period, this option must be used to ensure that these changes are taken into account." 20; N)
        $(O)--show_help$(N)
                $(o 17; GRAY; format_string "show the help output from the commands instead of brief usage message" 17; N)

        $(O)--firstrun$(N)
                $(o 17; GRAY; format_string "re-run the first run wizard" 17; N)

HELP
    if ((${#alternative_php_versions[@]})); then
        local plural
        plural="";[ ${#alternative_php_versions[@]} -gt 1 ]&&plural="s"
        ${X[cat]} << --PHP
        $(O)--php=$(dY)PHP-VERSION$(N)
                $(o 17; GRAY; format_string "invoke occ with another installed php version instead of the default $(C)${PHP[v]}" 17; N)
--PHP
        if [[ ${PHP[v]} != $php_version ]]; then
        ${X[cat]} << --PHP
                $(o 17; GRAY; format_string "actually used PHP-Version: $(C)$php_version" 17; N)
--PHP
        fi
        ${X[cat]} << --PHP
                $(o 17; GRAY; format_string "possible (installed) PHP-VERSION alternative$plural: $(listify_ C GRAY "${alternative_php_versions[@]}")" 17; N)
                    $(o 20; Y; format_string "example: --php=$(dY)${alternative_php_versions[0]}" 20; N)

--PHP
    fi
exit0
}
${B[help]} && help_

create_json_object(){
    local -i joe
    [[ -f "${F[occj]:=${D[occ]}/occ_commands.json}" ]] && joe=$(${X[stat]} -c %Z ${F[occj]})
    if (( T[rte] - joe > T[jttl] )); then
        occ list --format=json > "${F[occj]}"
    fi
    ${X[chown]} "${NC[u]}":"${NC[g]}" "${F[occj]}"
    ${X[chmod]} -f 666 "${F[occj]}"
}

# Persist the current NC_OCC_FAVORITES to disk
save_favorites() {
    {   echo "# ${F[occf]}"
        echo "# autogenerated on $(date -Iseconds)"
        declare -p NC_OCC_FAVORITES
    } > "${F[occf]}"
    ${X[chown]} "${NC[u]}":"${NC[g]}" "${F[occf]}"
    ${X[chmod]} -f 666 "${F[occf]}"
}

# Function to execute the full command
execute_command(){
    local command key ans raw_key fav_key
    local -A bool
    command="$*"
    command="${command%% }"
    o5; C; echo -n "Execute the command: $(Yi)occ $command"; N
    # 1) Check if this exact command is already in favorites
    bool[need_save]=:
    for key in "${!NC_OCC_FAVORITES[@]}"; do
        if [[ "${NC_OCC_FAVORITES[$key]}" == "$command" ]]; then
            GRAY; echo " (saved as favorite '$key')$(N)?"
            bool[need_save]=_
            break
        fi
    done
    if ${bool[need_save]}; then
        f 2
        cursor_ on
        read -rsn 1 -p "Press $(button s) to save as favorite, $(q2q), any other $(button key) to execute 'occ $command': " ans
        cursor_ off
        case $ans in
            q)  f; separator4; exit0 ;;
            s)  while :; do
                    cursor_ on
                    read -p "Enter a short key/name for this favorite: " raw_key
                    cursor_ off
                    fav_key="$(sanitize "$raw_key")"
                    if [[ -z $fav_key ]]; then
                        echo "Error: after sanitizing, key is empty. Please try again."
                        continue
                    elif [[ -n ${NC_OCC_FAVORITES[$fav_key]+_} ]]; then
                        echo "Key '$fav_key' already exists â†’ ${NC_OCC_FAVORITES[$fav_key]}"
                        if ask "Overwrite existing favorite" no; then
                            break
                        else
                            continue
                        fi
                    else
                        break
                    fi
                done
                NC_OCC_FAVORITES["$fav_key"]="$command"
                save_favorites
                echo "Saved as favorite '$fav_key'."
                f
                anykey "execute 'occ $command'"
                ;;
            *)  f
        esac
    else
        f
        anykey "execute 'occ $command'"
    fi
    f
    line _ lR a a2
    C; echo "occ $command:"
    line '-' C $((5 + ${#command})); N
    occ $command
    line _ lR a a2
}

show_favorites_menu() {
    declare -g MENU_CHOICE='' MENU_RESULT='' # purge any previous value
    local otf # options temp file
    otf="$(tf)"
    ${X[cat]} << OPTS >"$otf"
    bool[compose]=:
    title="nc-occ favorites menu"
    prompt="Select an occ command from the favorites"
    items=(${!NC_OCC_FAVORITES[@]})
    $(declare -p NC_OCC_FAVORITES | sed_ 's/NC_OCC_FAVORITES/descr/')
    x_items=(
        [n]="create a new command"
    )
OPTS
    (( "${#NC_OCC_FAVORITES[@]}" )) || parse_json 1
    # execute the command or exit on error
    if menu "$otf"; then
        case "$MENU_CHOICE" in
            n)  parse_json 1
                ;;
       [0-9]*)  f 2
                execute_command ${NC_OCC_FAVORITES[$MENU_RESULT]}
                return 0
                ;;
            *)  return 0
        esac
    else
        exit1
    fi
}

# Function to display a menu and select an option
show_menu(){
    declare -g MENU_CHOICE='' MENU_RESULT='' # purge any previous value
    local otf # options temp file
    local -i level
    otf="$(tf)" level="$1"
    shift
    ${X[cat]} << OPTS >"$otf"
    title="Level $level menu for occ command creation"
    prompt="Select an occ main-command from the list"
    items=($@)
    x_items=(
        [f]="return to favorites menu"
    )
OPTS
    (( level > 1 )) && ${X[cat]} << OPTS >>"$otf"
    prompt="Select an occ sub-command from the list"
    x_items+=(
        [r]="return to level 1 menu"
    )
OPTS
    # execute the command or exit on error
    if menu "$otf"; then
        case $MENU_CHOICE in
            f)  show_favorites_menu ;;
            r)  parse_json 1        ;;
            *)  return $MENU_CHOICE
        esac
    else
        exit1
    fi
}

# Function to parse the JSON file and create the menu
parse_json(){
    local -i level
    local special_commands selected_command choice description usage
    local -a special_options general_options options
    level=${1:-0} special_commands="check|completion|help|list|setupchecks|status|upgrade"

    if (( level == 1 )); then
        # List main categories, including special commands first
        mapfile -t special_options< <(${X[jq]} -r '.commands[].name' "${F[occj]}" | ${X[grep]} -E "^($special_commands)$" | ${X[sort]})
        mapfile -t general_options< <(${X[jq]} -r '.commands[].name | split(":")[0]' "${F[occj]}" | ${X[grep]} -Ev "^($special_commands)$" | ${X[grep]} -v '^_' | ${X[sort]} -u)
        options=("${special_options[@]}" "${general_options[@]}")
    else
        # List commands of the selected category
        local category="$2"
        mapfile -t options< <(${X[jq]} -r --arg category "$category" '.commands[] | select(.name | startswith($category + ":")) | .name' "${F[occj]}" | ${X[grep]} -v '^_' | ${X[sort]} -u)
    fi

    show_menu $level "${options[@]}"
    choice=$?

    if [[ "${options[choice]}" =~ ^($special_commands)$ ]]; then
        selected_command=${options[choice]}
        pf; echo "Command$(o 15;Yi)$selected_command"; N
        if "${B[include_help]}"; then
            execute_command "$selected_command" --help
        else
            execute_command "$selected_command"
        fi
    elif (( level == 1 )); then
        parse_json 2 "${options[choice]}"
    else
        selected_command=${options[choice]}
        pf; echo "Command$(o 15; Yi)$selected_command"; N
        if "${B[include_help]}"; then
            # long help
            # execute_command "$selected_command" --help
            pf; echo "Help"
            occ "$selected_command" --help | ${X[gawk]} '{print "   " $0}'
        else
            # brief usage message
            description="$(${X[jq]} -r --arg command "$selected_command" '.commands[] | select(.name == $command) | .description' "${F[occj]}")"
            usage="$(${X[jq]} -r --arg command "$selected_command" '.commands[] | select(.name == $command) | .usage[]' "${F[occj]}")"
            o3; GRAY; echo "Description$(N; o 15; format_string "$description" 15)"
            o3; GRAY; echo "Usage$(N; o 15; format_string "$usage" 15)"
        fi
#        parse_arguments "$selected_command"
        parse_options "$selected_command"
    fi
}

# Function to parse and select arguments
parse_arguments(){
    local command arguments description is_required
    local -a selected_options selected_arguments
    command=$1
    shift
    selected_options=("$@")

    mapfile -t arguments < <(${X[jq]} -r --arg command "$command" '.commands[] | select(.name == $command) | .definition.arguments | to_entries[] | .key' "${F[occj]}")

    for argument in "${arguments[@]}"; do
        description=$(${X[jq]} -r --arg command "$command" --arg argument "$argument" '.commands[] | select(.name == $command) | .definition.arguments[$argument].description' "${F[occj]}")
        is_required=$(${X[jq]} -r --arg command "$command" --arg argument "$argument" '.commands[] | select(.name == $command) | .definition.arguments[$argument].is_required' "${F[occj]}")

        separator
        pf; echo "Argument$(o 15)$argument"
        o3; GRAY; echo "Description$(N; o 15)$description"
        f
        if [[ $is_required == "true" ]]; then
            read -p "Enter the value for $argument: " value
            selected_arguments+=("$value")
        else
            if ask "$(qpf)Do you want to provide a value for $argument" "$Yes"; then
                read -p "Enter the value for $argument: " value
                selected_arguments+=("$value")
            fi
        fi
    done
    f
    if (( "${#selected_arguments[@]}" )); then
        execute_command "$command" "${selected_options[@]}" -- "${selected_arguments[@]}"
    else
        execute_command "$command" "${selected_options[@]}"
    fi
}

# Function to display and select options
parse_options(){
    local command unimportant_options option description accept_value default
    local -a options selected_options
    command=$1
    unimportant_options="help|quiet|verbose|version|ansi|no-ansi|no-interaction|no-warnings"

    if "${B[include_all_options]}"; then
        # Include all options
        mapfile -t options < <(${X[jq]} -r --arg command "$command" '.commands[] | select(.name == $command) | .definition.options | to_entries[] | .key' "${F[occj]}")
    else
        # Exclude common options
        mapfile -t options < <(${X[jq]} -r --arg command "$command" '.commands[] | select(.name == $command) | .definition.options | to_entries[] | .key' "${F[occj]}" | ${X[grep]} -Ev "^($unimportant_options)$")
    fi

    for option in "${options[@]}"; do
        accept_value=$(${X[jq]} -r --arg command "$command" --arg option "$option" '.commands[] | select(.name == $command) | .definition.options[$option].accept_value' "${F[occj]}")
        description=$(${X[jq]} -r --arg command "$command" --arg option "$option" '.commands[] | select(.name == $command) | .definition.options[$option].description' "${F[occj]}")
        default=$(${X[jq]} -r --arg command "$command" --arg option "$option" '.commands[] | select(.name == $command) | .definition.options[$option].default' "${F[occj]}")

        separator
        pf; echo "Option$(o 15)--$option"
        o3; GRAY;echo "Description$(N; o 15)$description"
        if [[ $default != "null" ]]; then
            o3; GRAY;echo "Default$(N; o 15)$default"
        fi
        f
        if [[ $accept_value == "true" ]]; then
            if ask "$(qpf)Do you want to set this option" "$NO" "$Yes"; then
                if [[ $default != "null" ]]; then
                    o3; read -p "Enter the value (default: $default): " value
                    value=${value:-$default}
                else
                    o3; read -p "Enter the value: " value
                fi
                selected_options+=("--$option=$value")
            fi
        else
            if ask "$(qpf)Do you want to enable this option" "$NO" "$Yes"; then
                selected_options+=("--$option")
            fi
        fi
    done
    parse_arguments "$selected_command" "${selected_options[@]}"
#    execute_command "$command" "${selected_options[@]}"
}

# Main
[ -f "${F[occf]:=${D[occ]}/favorites}" ] && . ${F[occf]} || {
    NC_OCC_FAVORITES=([config_list]="config:list" [update_all_updatable_apps]="app:update --all --allow-unstable" [maintenance_mode_off]="maintenance:mode --off" [show_updatable_apps]="app:update --all --showonly --allow-unstable" [maintenance_mode_on]="maintenance:mode --on" [support_report]="support:report" [status]="status" )
    save_favorites
}

create_json_object

show_favorites_menu || parse_json 1

separator4
exit0

